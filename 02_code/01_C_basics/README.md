
# C language 기초

자료구조를 배우기 전에 C프로그래밍 언어에 대한 지식이 필요하다. 최소한의 지식을 예제를 이용하여 소개하기로 한다.

- [C language 기초](#C-language-기초)
  * [프로그램 구성](#-------)
    + [컴파일](#컴파일)
    + [실행](#실행)
    + [Makefile를 이용한 컴파일,실행 자동화](#Makefile를-이용한-컴파일실행-자동화)
  * [입/출력 함수](#입출력-함수)
  * [C언어 기본 data type](#c------data-type)
    + [변수와 타입](#------)
    + [배열 (array)](#----array-)
    + [포인터 (pointer) 타입](#-----pointer----)
    + [구조체 (struct)](#-----struct-)
  * [메모리 동적 할당 (malloc)](#메모리-동적-할당-(malloc))
  * [void pointer](#void-pointer)


## 프로그램 구성
C언어로 구현한 프로그램은 함수의 집합으로 구성되어 있다. 함수 중에 반드시 main()이란 이름의 함수가 존재해야 하며
프로그램이 시작될 때 main 함수를 실행한다. 함수는 리턴타입, 함수명, ( )안에 입력 변수, 그리고 { } 안에 함수 body로 구성되며, 함수 body에는 반드시 마지막에 리턴 값을 반환해야 한다. 따라서 가장 기본적인 함수 구성은 아래과 같다.

``` c
int main() {
  return 0;
}
```

### 컴파일

위에 작성한 파일을 foo.c로 저장했다고 가정하자. C컴파일러를 이용하여 실행파일을 아래와 같이 생성해보자.

``` shell
% gcc -o foo foo.c
```

%는 터미널에 표시된 기호이며 사용하는 시스템 마다 약간씩 다를 수 있다. 명령어 gcc는 gnu c compiler의 약자로 gcc라는 프로그램을 호출하는 것을 의미한다. -o는 출력 생성 파일을 지정하는 것으로 다음에 오는 foo가 생성될 파일 명이다. 따라서 사용자가 워하는 다른 이름을 지정해도 된다. 마지막 foo.c가 컴파일러의 입력으로 전달할 C 코드가 된다. 

### 실행

성공적으로 에러없이 컴파일이 되었다면 foo가 생성되었을 것이다. ls 명령어를 이용하여 현재 폴더를 확인하면 다음과 같다.

``` shell
% ls
foo foo.c 
```

생성된 실행파일 foo를 이제 실행해보자.
``` shell
% ./foo
```

### Makefile를 이용한 컴파일,실행 자동화

C코드를 수정한 뒤 컴파일, 실행을 매번 수행하지 않고 자동화 해보자. make라는 실행 자동화 도구를 이용한다. 실행할 내용을 Makefile이란 파일에 다음과 같이 작성한다. 파일명이 정확히 Makefile이어야 하므로 주의한다.

``` make
all:
      gcc -o foo foo.c
      ./foo
      
```

위의 Makefile안에 작성한 코드 가운데 gcc 앞에 공백은 반드시 tab이어야 한다. 커맨드 콘솔에서, 다음과 같이 입력해본다.

``` shell
% make all
gcc -o foo foo.c
./foo
```

make 명령어 다음에 지정한 all에 해당하는 코드를 Makefile내에서 찾아서 그 하위의 모든 코드를 일괄 실행하게 된다.

## 입/출력 함수

자 이제 C 언어를 이용하여 사용자 인터페이스인 입/출력 처리를 해보자. C언어는 printf라는 함수를 라이브러리로 제공한다. 다음의 코드를 보고 printf 함수 활용법을 예제로 파악하자. printf는 stdio.h라는 라이브러리 파일에 정의되어 있으므로 #include를 이용하여 프로그램에 포함시켜 주어야 한다.

``` C
#include <stdio.h>

int main() {
  int a;
  a = 10;
  
  printf("a is %d\n", a);
}
```

" " 사이에는 화면에 출력될 데이트를 지정하며 %d로 지정된 부분은 ,이후에 지정된 변수값을 순서대로 읽어서 채워지게 된다. %d는 값이 정수를 의미한다. 값의 포맷을 줄수 있다. %d, %f, %x, %p 등이 있으며 자세한 내용은 정식 C언어 교재를 참고하기 바란다. 

프로그램 내부의 변수의 값들을 화면으로 출력할 수 있다면, 이제 사용자로부터 입력을 받아서 프로그램 내부 변수에 채워보자. C언어는 scanf라는 함수를 라이브러리로 제공하여 사용자 입력을 프로그램 내부로 읽어들일 수 있다. 다음의 코드를 보고 활용법을 이해하자.

``` C
#include <stdio.h>

int main() {
  int a;
  a = 10;
  b;
  
  printf("a is %d\n", a);
  
  scanf("enter b: %d", &b);
  printf("b is %d\n", b);
    
}
```
scanf 함수에 " " 사이에 문자열을 일단 화면에 출력이 되며, 사용자가 입력하는 값이 %d로 지정된 포맷으로 (정수형) 변환되어 분수 b로 전달된다. 이때 반드시 저장될 변수의 주소 &b를 scanf의 입력으로 정의해야 한다.


## C언어 기본 data type

### 변수와 타입

프로그램은 기본적으로 데이타를 다루는 프로세싱 언어이다. 따라서 프로그램에서 사용할 데이타를 정의해야 한다. 정의할 때는 데이타의 이름 (변수명), 크기 및 값의 종류 (타입)가 필요한다. 따라서 C언어에서는 이 2가지 정보를 표현하기 위해 [타입] [변수명]; 문법적 형태를 따른다. 예를 들어 정수형 값을 가지는 변수명 a는 다음과 같이 정의될 수 있다.

``` C
int a;
int b, c, d;
float f;
long g;
double h;
```

C언어는 다양한 형태의 타입을 지원한다. 자세한 내용은 정식 c언어 교재를 참고한다. 분명한 것은 변수 명 앞에 타입을 지정하여 변수에 들어갈 값이 종류와 그 크기를 제한한다는 사실이다. 다른 종류의 값이 저장되거나, 크기를 초과할 경우 컴파일 에러가 발생한다.


### 배열 (array)

같은 타입을 가지는 변수를 복수개로 반복적으로 선언할 필요가 있을 경우 모든 변수의 이름을 다르게 주는 것은 비효율적이다. 따라서 C언어는 배열을 지원하여 하나의 변수에 대해 복수의 데이타 집합으로 표현할 수 있는 배열을 지원한다. 아래의 예를 보자. 변수의 크기를 지정하는 부분만 다르다.

``` C
int a[100];
```

변수 a는 배열이며 100개의 int타입의 값을 담을 수 있는 공간이 정의된다. 각각의 공간에는 a[인덱스]의 형태로 접근이 되며 0에서부터 99까지 주소를 가진다. 주의할 점은 항상 인덱스가 0에서 출발하므로 배열 크기보다 1작은 값이 마지막 접근 가능한 인덱스가 된다는 점에 주의하자.

``` C
int a[100];
a[0] = 12;
a[1] = 34;
...

a[99] = 78;
// a[100] = 36; not allowed 
```


### 포인터 (pointer) 타입

C언어는 데이타를 다루는 언어의 하나로, 변수에 저장된 데이트를 처리하며, 그 변수는 선언될 때 정확한 타입으로 지정된다고 앞에서 서술했다.
정수, 소수, 문자, 문자열, 등 다양한 데이타 값의 종류 (타입) 중에 그 값이 변수의 주소일 경우 우리는 이를 포인터라고 한다.

사실 변수는 메모리의 한 공간을 차지하며 이는 특정 주소에 위치하고 있음을 의미한다. 변수의 주소는 십진수, 16진수로 표현될 뿐이지 사실상 주소값은 정수이다. 따라서 C언어에서는 그 값이 변수의 주소를 의미한다고 명확하게 표현할 수 있는 언어적인 문법을 제공한다. 아래의 예를 보자.

``` C
int a = 10;
int* ap;
```

변수 a는 메모리 공간에 특정 영역을 차지하며 그 공간에는 정수값만 들어갈 수 있으며 값 10이 저장되었다. 두번째 문장을 보면 타입 뒤에 * 를 사용한 것을 알 수 있다. 이렇게 변수를 선언할 때 타입을 지정하는 자리에 * 가 들어가 있으면 포인터 즉 주소값을 담을 수 있는 변수가 정의된다. 그 주소가 가르키는 공간에 값은 int라는 의미이다. 뒤에서부터 읽어보면 ap라는 변수가 정의되고, 그 변수 안에는 특정 종류의 값만 들아갈 수 있는데 * 가 붙었으므로 주소 값이 담길 것이고, 그 주소값을 따라가보면 int라는 정수값이 존재한다는 말이다. 그럼 다음 코드를 살펴보자.

``` C
int a = 10;
int* ap;

ap = &a;

```

어떤 변수가 메모리상에 위치한 주소를 알아내는 것은 어렵다. 알아낸다 하더라도 그 값은 의미가 없다. 다른 변수가 추가되거나, 실행할 때마다 달라질 수 있기 때문이다. 따라서 C언어에서는 변수의 주소를 알아낼 수 있는 표현방법을 제공하며, &를 변수 앞에 붙이면 된다. 

그럼 포인터 변수를 이용하여 그 포인터(주소)가 가르키는 공간의 변수값에 접근해보자. C언어는 포인터 변수 앞에 * 를 붙여서 주소를 따라가서 해당 영역의 값을 읽거나 쓸 수 있도록 접근을 허용한다. 다음의 코드를 보자. 포인터가 가르키는 공간의 값 즉 변수 a의 값을 읽을 수도 있지만 다른 값을 덮어쓸수도 있음을 숙지하자.


``` C
int a = 10;
int * ap;
ap = &a;

printf("a is %d\n", *ap);

*ap = 100;

printf("a is %d\n", *ap);
```

### 구조체 (struct)

하나의 추상적인 데이타를 하나의 타입만으로 표현하기 부족한 것이 일반적이다. 따라서 기본 타입으로 정의된 여려개의 변수를 묶어서 하나의 개체를 표현할 수 구조체 (struct)에 대해 알아보자. 다음의 코드를 보고 무엇인지 파악해보자.

``` C
struct student {
	char name[20];
	int age;
	int score;
};
```

각각의 변수를 property나 member라고도 부른다. 각각의 변수는 끝에 ; 로 끝나야 하며, 전체는 { } 로 묶여 있으며 마지막에 ;로 끝나야 함에 주의하자.
변수를 정의하고 초기값을 채워보자.

``` C
struct student s1 = {"Hong", 23, 99};

printf("Student Name: %s\n", s1.name);
printf(" --> age  : %d\n", s1.age);
printf(" --> score: %d\n", s1.score);
```

s1이라는 변수를 정의함에 있어 그 타입을 구조체 struct student라는 타입으로 지정했다. 항상 뒤에서부터 변수 정의를 해석하면 된다.
구조체 내부 변수에 접근할 때는 .을 이용하면 된다.

구조체를 가르키는 포인터 변수를 이용해보자.

``` C
struct student s1 = {"Hong", 23, 99};
struct student* s1_p = &s1;

printf("Student Name: %s\n", s1_p->name);
printf(" --> age  : %d\n", s1_p->age);
printf(" --> score: %d\n", s1_p->score);
```

두번째로 정의된 변수 s1_p에 대해 해석해보자. s1_p라는 변수가 생성되고 하나의 공간을 차지한다. 그 안에 어떤 값을 담을 수 있는 공간인데 그 값은 포인터, 즉 주소만 담을 수 있고 그 주소를 따라가보니 해당 공간에 저장될 값의 종류는 struct student라는 구조체형태라는 것을 알 수 있다. 

포인터 변수로 구조체의 내부 변수에 접근할 때는 .이 아니라 ->를 이용하여 쉽게 접근할 수 있다.


## 메모리 동적 할당 (malloc)

일반적인 변수는 코드에 정의됨과 동시에 바로 메모리 공간에 할당된다. 이것은 사람(프로그램)이 태어나자 마자 일정한 재산(변수)을 가지고 태어나는 것과 같다. 혹은 매년 학기초에 입학과 동시에 예약한 사물함을 미리 할당받는 것과 같다. 변수를 함수 초반에 정의하는 것은 이렇게 사물함을 미리 예약해서 할당받는 효과를 얻는다. 이것은 지금가지 다루어왔던 일반적인 변수 선언과 같다.

``` C
int a[100]; // 100개의 사물함을 할당.

```

반면 학기중에도 수시로 사물함 신청을 받아서 추가로 사물함을 구매하여 설치한 뒤 요청하는 학생에게 할당해줄 수 있을 것이다. 이것은 C언어에서 동적 메모리 할당에 해당된다.

``` C
int locker[100];
int* locker_plus;

int num;
scanf("%d", &num); // 사용자가 100을 입력시

if(num >= 1) {
	locker_plus = (int*)malloc(sizeof(int)*num);
	// int형을 담을수 있는 크기의 공간을 num개 생성하고 그 시작 주소를 반환.
}

locker_plus[0] = 12;
locker_plus[1] = 35;
locker_plus[99] = 123;
```

위의 코드에서 int locker[100]; 코드에 의해 프로그램 실행과 동시에 int형의 값을 담을 수 있는 공간 100가 자동으로 생성된다.
사용자로부터 입력을 받아서 변수 num에 저장한다. 그 값이 0보다 클 경우 malloc함수가 실행되어 메모리를 새로 동적으로 할당받게 된다.

malloc에 들어갈 인자는 할당받을 메모리의 크기를 지정한다. 우리는 int형을 담을 수 있어야 함으로 int형 변수의 크기를 sizeof를 이용하여 지정하고, 그러한 변수를 num개 할당해야 하므로 num을 곱하였다. malloc 함수는 운영체제에 메모리 할당을 요청하여 공간을 할당 받고 그 시작주소를 반환한다. 이때 그 주소가 가르키는 곳의 값이 int이므로 int* 리턴 값을 변한해야 하는 것에 주의하자. 이렇게 할당받은 공간의 첫 주소 locker_plus로부터 개별 공간 각각에 locker_plus[0], locker_plus[1] ... 등 과 같이 접근이 가능하다.

## void pointer

포인터 타입은 변수에 담을 값의 종류를 변수의 주소로 한정할 때 사용한다. 만약 변수의 타입을 포인터 타입으로 지정시 이 변수를 포인터 변수라고 한다. 이러한 포인터 변수에 주소를 담을 때는 그 주소가 가르키는 공간의 값의 종류가 포인터 타입과 일치해야 한다. 다음을 살펴보자.

``` C

int a;
float f;

int* ap;
ap = &a; 
ap = &f; // error happens
```

위의 코드의 마지막 라인은 에러를 발생시킨다. 포인터 변수 ap는 int* 로 값의 타입을 제한하였다. 즉 변수 ap는 주소를 담을 수 있는 포인터 변수이지만, 그 주소가 가르키는 공간의 값이 int라는 것을 내포하고 있다. 따라서 변수 f의 주소 &f를 ap에 저장하게 되면 그 주소가 가르키는 공간 즉 f의 타입이 float이므로 일치하지 않아서 에러를 발생시킨다.

C언어에서는 임의의 모든 주소를 가르킬 수 있는 void* 를 지원한다. 그러나 주소를 따라가서 그 실체에 접근할 때는 해당 자료형으로 casting 해야함에 주의하자. 아래의 코드를 살펴보자. 

``` 
int a;
float f;

void* p;

p = &a; 
printf("a is %d\n", *((int*)p) );

p = &f; // no error happens
printf("f is %f\n", *((float*)p) );

```

앞으로 자료구조 강의에서는 모든 타입의 변수를 가르킬 수 있는 void* 를 주로 사용할 것이므로 원리를 잘 이해해야 한다.
